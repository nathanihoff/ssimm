---
output:
  bookdown::pdf_document2:
  # bookdown::word_document2:
  #   reference_docx: "word-template.docx"
    toc: yes
    number_sections: yes
    pandoc_args: !expr rmdfiltr::add_wordcount_filter(rmdfiltr::add_citeproc_filter(args = NULL))
    latex_engine: xelatex
    keep_tex: no
    #template: svm-latex-ms.tex
# output: 
#   pdf_document:
#     citation_package: natbib
#     keep_tex: true
#     fig_caption: true
#     latex_engine: pdflatex
#     template: svm-latex-ms.tex
header-includes:
#  - \usepackage{setspace}\doublespace
  - \usepackage{bbm}
  - \usepackage{fancyhdr}
  - \usepackage{amsmath}
  # - \pagestyle{fancy}
  # - \setlength{\headheight}{15pt}
  # - \lhead{Hoffmann and Velasco}
  # - \rhead{`r format(Sys.time(), '%B %e, %Y')`}
editor_options: 
  
  chunk_output_type: console
citeproc: no
# fontfamily: mathpazo
mainfont: "Times New Roman"
fontsize: 12pt
geometry: margin=1in
indent: yes
link-citations: yes
linkcolor: blue
bibliography: "/Users/nathan/My Drive/Projects/2020 Same-Sex Immigrant Couples/ssimm/Same-Sex Immigration.bib"
csl: american-sociological-association.csl
title: "Online Appendix"
subtitle: "Policy Effects on Mixed-Citizenship, Same-Sex Unions: A Triple-Difference Analysis"
# date: "`r format(Sys.time(), '%B %e, %Y')`"
# author:
# - Nathan I. Hoffmann, Department of Sociology, University of California, Los Angeles
# - Kristopher Velasco, Department of Sociology, Princeton University

---

<!-- Turn off hyphenation -->
<!-- \usepackage[none]{hyphenat} -->


```{r setup, include=F}
library(knitr)
library(broom)
library(huxtable)
library(sandwich)
library(lmtest)
library(here)
library(stargazer)
library(patchwork)
library(flextable)
library(tidyverse)
library(kableExtra)

knitr::opts_chunk$set(echo = F, warning = F, message = F, cache = T, # results = 'asis',
                      cache.lazy = F, dpi = 600)

# knitr::opts_chunk$set(error=TRUE) 

options("yaml.eval.expr" = TRUE)

uclablue = '#2774AE'
gray = '#808080'
black = '#000000'
uclagold = '#FFB81C'
ucla_palette = c(uclablue, black, gray)

# theme_set(theme_cowplot(font_family = 'Palatino') + 
theme_set(theme_classic(base_family = 'Palatino') + 
            theme(legend.title=element_blank(), 
                  panel.grid.major.y = element_line('grey80'),
                  legend.background = element_rect(fill = "transparent")))
# ggplot <- function(...) ggplot2::ggplot(...) + scale_color_manual(values = ucla_palette) +
#   scale_fill_manual(values = ucla_palette)
ggplot <- function(...) ggplot2::ggplot(...) + scale_color_brewer(palette="Dark2") +
  scale_fill_brewer(palette="Dark2")

# library(colorspace)
# colorspace_palette = 'RdPu'
# ggplot <- function(...) ggplot2::ggplot(...) +
#   scale_color_discrete_sequential(palette=colorspace_palette) +
#   scale_fill_discrete_sequential(palette=colorspace_palette)

options(scipen=1, digits=2)
knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark=",")
})
knitr::opts_chunk$set(error=TRUE) 

set_flextable_defaults(font.family = 'Times New Roman',
                       # padding.bottom = 1,
                       # padding.top = 1,
                       # padding.left = 3,
                       # padding.right = 1,
                       theme_fun = 'theme_booktabs',
                       digits = 3, 
                       big.mark = ',',
                       line_spacing = 1)

defOut <- knitr::knit_hooks$get("plot")  # save the default plot hook 
knitr::knit_hooks$set(plot = function(x, options) {  # set new plot hook ...
  x <- defOut(x, options)  # first apply the default hook
  if(!is.null(options$wrapfigure)) {  # then, if option wrapfigure is given ...
    # create the new opening string for the wrapfigure environment ...
    wf <- sprintf("\\begin{wrapfigure}{%s}{%g\\textwidth}", options$wrapfigure[[1]], options$wrapfigure[[2]])
    x  <- gsub("\\begin{figure}", wf, x, fixed = T)  # and replace the default one with it.
    x  <- gsub("{figure}", "{wrapfigure}", x, fixed = T)  # also replace the environment ending
  }
  return(x)
})
```

```{r load, include = F}
acs_count_base <- read_csv(here('data', 'acs_count_base.csv')) %>%
  filter(is.na(yrimmig) | !is.na(origin_score)) %>%
  filter(state != 'District of Columbia') %>%
  mutate(across(equal_age:propaganda, function(x) round(x)),
         yrmarr = as.numeric(yrmarr))

state_df <- read_csv(here('data', 'state_df.csv'))

count_func <- function(condition = '!is.na(state)'){
  acs_count_base %>%
    filter(eval(rlang::parse_expr(condition))) %>%
    rename(mixed = mixed_citizenship) %>%
    group_by(state, year, same_sex, mixed) %>%
    summarize(n = sum(perwt), 
              n_unweighted = n(),
              n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
              n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
    ungroup() %>%
    complete(state, year, same_sex, mixed) %>%
    mutate(across(n:n_unweighted_ar, function(x) ifelse(is.na(x), 0, x))) %>%
    mutate(post_2013 = year > 2013,
           group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
    left_join(state_df)
}

# acs_count_base %>%
#   filter(state == 'Alabama', year == 2008) %>%
#   group_by(same_sex, mixed_citizenship, bpldnew) %>%
#     summarize(n = sum(perwt), 
#               n_unweighted = n(),
#               n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
#               n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
#   group_by(same_sex, mixed_citizenship) %>%
#    summarize(n = sum(n),
#             n_unweighted = sum(n_unweighted),
#             n_ar = sum(n_ar),
#             n_unweighted_ar = sum(n_unweighted_ar))

acs_count_mixed <- count_func()




# acs_count_mixed <- read_csv(here('data', 'acs_count_mixed.csv')) %>%
#   group_by(state, year, same_sex, mixed) %>%
#   summarize(n = sum(n),
#             n_unweighted = sum(n_unweighted),
#             n_ar = sum(n_ar),
#             n_unweighted_ar = sum(n_unweighted_ar)) %>%
#   mutate(post_2013 = year > 2013,
#          group_fe = paste(state, same_sex, mixed, sep = '_'))
# acs_prop <- read.csv(here('data', 'acs_prop_yrimmig_policy.csv')) %>%
#   mutate(post_2013 = (yrimmig > 2013))
# acs_prop_state <- read.csv(here('data', 'acs_dyad_policy.csv'))

lgb_origin_index <- read_csv(here('data', 'lgb_origin_index.csv'))
acs_ind <- read_rds(here('data', 'acs_couple_policy.rds'))  %>%
  mutate(post_2013 = year > 2013
         # mixed =  mixed_citizenship = (citizen_main == 'Not a citizen' & citizen_partner != 'Not a citizen') | 
         #   (citizen_main != 'Not a citizen' & citizen_partner == 'Not a citizen')
         ) %>%
  left_join(lgb_origin_index,  by = c('yrimmig' = 'year', 'bpldid' = 'Code')) 

acs_count_mixed_bpld <- read_csv(here('data', 'acs_count_mixed.csv'))  %>%
  left_join(
    acs_ind %>%
      group_by(year, state, bpld, same_sex) %>% 
      summarize(across(c(equal_age:propaganda, origin_score), mean, na.rm = T))
      #summarize(origin_score = mean(origin_score))
  ) %>%
  filter(!is.na(origin_score) | bpld %in% unique({.$state}))


```

# (APPENDIX) Appendix {-} 

\newpage

# Sensitivity to Hypothetical Sex Misreporting

Published papers using the ACS to study same-sex couples overwhelmingly use the method by @gates_2009 employed our main paper to adjust for misreporting, where we drop all respondents that had either their relationship or sex variable allocated by the Census Bureau. However here we implement a novel method to adjust proportions of estimated immigrants in same-sex couples, based on the estimated mismatch rates from two U.S. Census Bureau studies. Beginning in 2019, the ACS provides explicit categories for "Opposite-sex husband/wife/spouse," "Opposite-sex unmarried partner," "Same-sex husband/wife/spouse," and "Same-sex unmarried partner" [@walker_2021], so sex misreporting in the 2019 data is unlikely, but we still adjust mismatch rates in these years as well.  

In a Census Bureau working paper, @kreider_2015 use personal information such as names and addresses match same-sex couples from the 2010 ACS to Social Security administrative data. They find that 7 percent of unmarried couples coded as same-sex in the ACS are coded as different-sex in the administrative data, and 57 percent of married same-sex couples. A follow-up study [@kreider_2017] shows that these mismatch rates appear to have fallen: In a 2016 ACS test module that included explicit categories for different- and same-sex spouses and partners, 31 percent of married and 3 percent of unmarried same-sex couples had inconsistent sex responses.  

To test the robustness of our results these levels of misreporting, we re-assign up to 60 percent of counts of individuals in same-sex couples to counts in different-sex couples, within state, year, and citizenship group. We then re-fit the models reported in the main paper, with state-level controls. Coefficients for the three-way interaction of interest are shown in Figure \@ref(fig:misreporting-plot). Results are extremely robust to even high levels of sex misreporting. Since we model a relative rather than absolute change, this robustness makes sense.   


```{r misreporting, eval = F}
# count_origin_high <- count_func('origin_score > 3 | is.na(origin_score)') 
# count_origin_low <- count_func('origin_score < 0 |  is.na(origin_score)')

misreport <- function(dataset, rates = seq(0, 0.6, length.out = 7)){
  df <- dataset %>%
    select(state, year, same_sex, mixed, n) %>%
    pivot_wider(names_from = same_sex, values_from = n, names_prefix = 'same_sex_') 
  
  df[paste0(as.character(rates), '-TRUE')] <- round(sapply(1-rates, function(x)x*df$same_sex_TRUE))
  df[paste0(as.character(rates), '-FALSE')] <- round(sapply(rates, function(x){x*df$same_sex_TRUE + df$same_sex_FALSE}))
    
  df %>%
    select(-c(same_sex_FALSE, same_sex_TRUE)) %>%
    pivot_longer(cols = c(paste0(as.character(rates), '-TRUE'), paste0(as.character(rates), '-FALSE')),
                 names_sep = '-',
                 names_to = c('rate', 'same_sex'),
                 values_to = 'n') %>%
    mutate(same_sex = as.logical(same_sex)) %>%
    left_join(select(dataset, -starts_with('n')))
}

data_list <- list(
  'Full sample' = misreport(acs_count_mixed),
  'Progressive' = misreport(count_origin_high),
  'Regressive' = misreport(count_origin_low)
)

mis_list <- list()

# test <- misreport(count_origin_high)

for(rate_loop in as.character(unique(data_list[[1]]$rate))){
  for(dataset_num in 1:3){
    print(rate_loop)
    mis_list[[paste0(rate_loop, dataset_num, '1')]] <- data_list[[dataset_num]] %>%
      filter(rate == rate_loop) %>%
      glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) + 
            
          post_2013 + group_fe + as.factor(year), 
                          data = ., 
                          family = 'quasipoisson') %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
      tidy() %>%
      filter(term == 'I(post_2013 * same_sex * mixed)') %>%
      mutate(rate = as.numeric(rate_loop), 
             policy = names(data_list)[dataset_num],
             model = 'Main effects')
    
    mis_list[[paste0(rate_loop, dataset_num, '2')]] <- data_list[[dataset_num]] %>%
      filter(rate == rate_loop) %>%
      glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) +
          state_policy + state_income + state_unemploy +
          post_2013 + group_fe + as.factor(year), 
                          data = ., 
                          family = 'quasipoisson') %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
      tidy() %>%
      filter(term == 'I(post_2013 * same_sex * mixed)') %>%
      mutate(rate = as.numeric(rate_loop), 
             policy = names(data_list)[dataset_num],
             model = 'With controls')
  }
}


write_csv(bind_rows(mis_list), here('did', 'misreporting_df.csv'))
```

```{r misreporting-plot, fig.cap = 'Coefficients for the three-way interaction between indicators for same-sex, mixed-citizenship, and post-2013 survey year from Table 5, with counts of individuals in same-sex couples in the sample reduced by 10 to 60 percent'}
misreporting_df <- read_csv(here('did', 'misreporting_df.csv')) %>%
  filter(model == 'With controls')

ggplot(misreporting_df, aes(x = rate, y = estimate, color = policy)) +
  geom_pointrange(aes(ymin = estimate - 1.96*std.error, ymax = estimate + 1.96*std.error), 
                  position = position_dodge(.02)) +
  # facet_wrap(~model, ncol= 1) +
  geom_hline(yintercept = 0) +
  labs(x = 'Hypothetical misreporting rate', y = 'Coefficient for 3-way interaction')
```

<!-- \newpage -->

<!-- # Simple-Difference and Difference-in-Differences with State-Level Controls -->
<!-- ```{r D-mod} -->
<!-- count_origin_high <- count_func('origin_score > 3 | is.na(origin_score)')  -->
<!-- count_origin_low <- count_func('origin_score < 0 |  is.na(origin_score)') -->

<!-- mod_mixed <- acs_count_mixed %>% -->
<!--   filter(same_sex == T, mixed == T) %>% -->
<!--   glm(n ~ post_2013 + group_fe + as.factor(year)+ -->
<!--         state_policy + state_income + state_unemploy,  -->
<!--                         data = .,  -->
<!--                         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe))  -->

<!-- mod_os_high <- count_origin_high %>% -->
<!--   filter(same_sex == T, mixed == T) %>% -->
<!--   glm(n ~ post_2013 +  -->
<!--         state_policy + state_income + state_unemploy + -->
<!--         group_fe + as.factor(year),  -->
<!--         data = .,  -->
<!--         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe)) -->

<!-- mod_os_low <- count_origin_low %>% -->
<!--   filter(same_sex == T, mixed == T) %>% -->
<!--   glm(n ~ post_2013 +  -->
<!--         state_policy + state_income + state_unemploy + -->
<!--         group_fe + as.factor(year),  -->
<!--         data = .,  -->
<!--         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe)) -->


<!-- huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low), -->
<!--        coefs = c('Post-2013' = 'post_2013TRUE', -->
<!--                  'State LGB policy' = 'state_policy', -->
<!--                 'State unemployment' = 'state_unemploy', -->
<!--                 'State per-capita income' = 'state_income'), -->
<!--   note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.', -->
<!--        stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001), -->
<!--        statistics = c('Observations' = 'nobs')) %>% -->
<!--   huxtable::set_width(1) %>% -->
<!--   set_wrap(T) %>%  -->
<!--   set_all_padding(0) %>% set_caption_pos('topleft') %>% -->
<!--   huxtable::set_caption('Simple-difference (D), quasi-Poisson regressions of counts of  -->
<!--                         individuals in mixed-citizenship, same-sex couples couples, stratifying the sample by policy environment at year of immigration. The sample includes only mixed-citizenship, same-sex couples couples.') -->


<!-- ``` -->

<!-- \newpage -->

<!-- ```{r DD-mod} -->
<!-- mod_mixed <- acs_count_mixed %>% -->
<!--   filter(same_sex == T) %>% -->
<!--   glm(n ~ I(post_2013*mixed) +  -->
<!--         state_policy + state_income + state_unemploy + -->
<!--         post_2013 + group_fe + as.factor(year),  -->
<!--                         data = .,  -->
<!--                         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe))  -->

<!-- mod_os_high <- count_origin_high %>% -->
<!--   filter(same_sex == T) %>% -->
<!--   glm(n ~  I(post_2013*mixed) +  -->
<!--         post_2013 +  -->
<!--         state_policy + state_income + state_unemploy + -->
<!--         group_fe + as.factor(year),  -->
<!--         data = .,  -->
<!--         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe)) -->


<!-- mod_os_low <- count_origin_low %>% -->
<!--   filter(same_sex == T) %>% -->
<!--   glm(n ~  I(post_2013*mixed) +  -->
<!--         post_2013 +  -->
<!--         state_policy + state_income + state_unemploy + -->
<!--         group_fe + as.factor(year),  -->
<!--         data = .,  -->
<!--         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe)) -->


<!-- huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low), -->
<!--        coefs = c('Post-2013 × Mixed-citizenship' = 'I(post_2013 * mixed)', -->
<!--                 'Post-2013' = 'post_2013TRUE', -->
<!--                 'State LGB policy' = 'state_policy', -->
<!--                 'State unemployment' = 'state_unemploy', -->
<!--                 'State per-capita income' = 'state_income'), -->
<!--   note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.', -->
<!--        stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001), -->
<!--        statistics = c('Observations' = 'nobs')) %>% -->
<!--   huxtable::set_width(1) %>% -->
<!--   set_wrap(T) %>%  -->
<!--   set_all_padding(0) %>% set_caption_pos('topleft') %>% -->
<!--   huxtable::set_caption('Difference-in-difference (DD), quasi-Poisson regressions of counts of individuals in  -->
<!--                         mixed-citizenship, same-sex couples couples, stratifying the sample by policy environment at year of immigration') -->
<!-- ``` -->

\newpage

# Alternative Outcome Variables
```{r nativity}
count_func_mixed_nat <- function(condition = '!is.na(state)'){
  acs_count_base %>%
    mutate(mixed = imm_couple == 'one') %>%
    filter(eval(rlang::parse_expr(condition))) %>%
    group_by(state, year, same_sex, mixed) %>%
    summarize(n = sum(perwt), 
              n_unweighted = n(),
              n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
              n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
    ungroup() %>%
    complete(state, year, same_sex, mixed) %>%
    mutate(across(n:n_unweighted_ar, function(x) ifelse(is.na(x), 0, x))) %>%
    mutate(post_2013 = year > 2013,
           group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
    left_join(state_df)
}


mod_mixed <- count_func_mixed_nat() %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_func_mixed_nat('origin_score > 3 | is.na(origin_score)') , 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_func_mixed_nat('origin_score < 0 |  is.na(origin_score)'), 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-nativity' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-nativity'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>% 
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Mixed vs. Same Nativity: Triple-difference (DDD), quasi-Poisson 
  regressions of counts of individuals in mixed-nativity, same-sex couples couples, stratifying by 
  state-country-year-group average policy environment')
```

\newpage

```{r imm-containing}
count_func_imm <- function(condition = '!is.na(state)'){
  acs_count_base %>%
    mutate(mixed = imm_couple %in% c('one', 'two')) %>%
    filter(eval(rlang::parse_expr(condition))) %>%
    group_by(state, year, same_sex, mixed) %>%
    summarize(n = sum(perwt), 
              n_unweighted = n(),
              n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
              n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
    ungroup() %>%
    complete(state, year, same_sex, mixed) %>%
    mutate(across(n:n_unweighted_ar, function(x) ifelse(is.na(x), 0, x))) %>%
    mutate(post_2013 = year > 2013,
           group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
    left_join(state_df)
}

mod_mixed <- count_func_imm() %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_func_imm('origin_score > 3 | is.na(origin_score)') , 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_func_imm('origin_score < 0 |  is.na(origin_score)'), 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Immigrant-containing' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Immigrant-containing'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>% 
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Immigrant-containing couples vs. two U.S.-born: Triple-difference (DDD), quasi-Poisson regressions of counts of individuals 
  in immigrant-containing, same-sex couples couples, stratifying by 
  state-country-year-group average policy environment')
```


\newpage

# Timing of Migration and Union Formation
```{r diff-hist, fig.cap = 'Distribution of difference in year of marriage and year of immigration for the noncitizen in mixed-citizenship couples'}
marr_dif <- acs_count_base %>%
  filter(mixed_citizenship == T) %>%
  group_by(same_sex) %>%
  summarize(marr_median = median(marr_minus_imm, na.rm = T))

acs_count_base %>%
  filter(mixed_citizenship == T) %>%
  left_join(marr_dif) %>%
  mutate(same_sex = ifelse(same_sex == T, 'Same-sex', 'Different-sex')) %>%
  ggplot(aes(x = marr_minus_imm)) +
  geom_histogram() +
  geom_vline(aes(xintercept = marr_median)) +
  facet_wrap(~same_sex, scales = 'free_y') +
  labs(x = '(Year of Marriage) - (Year of Immigration)')
```

```{r diff-fig, fig.cap = 'Mean LGB policy score over difference in year of marriage and year of immigration. Lines are smoothed by categorizing data into two-year bins.'}
acs_count_base %>%
  filter(mixed_citizenship == T,
         abs(marr_minus_imm) < 30) %>%
  mutate(marr_minus_imm = floor(marr_minus_imm/2)*2) %>%
  group_by(same_sex, marr_minus_imm) %>%
  summarize(mean = mean(origin_score, na.rm = T),
            se = sd(origin_score, na.rm = T)/sqrt(n()),
            upper = mean + 1.96*se,
            lower = mean - 1.96*se) %>%
  filter(!is.na(se)) %>%
  mutate(same_sex = ifelse(same_sex == T, 'Same-sex', 'Different-sex')) %>%
  ggplot(aes(x = marr_minus_imm, y = mean)) +
  geom_line() + 
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .3) +
  facet_wrap(~same_sex) +
  labs(x = '(Year of marriage) - (Year of immigration)', y = 'Mean LGB policy score of origin')
```


```{r diff-desc, fig.cap = "Estimated counts of individuals in mixed-citizenship, same-same, married couples from the American Community Survey, stratified by whether couples married before or after immigration of the non-citizen partner. The Regressive sample includes only countries with a LGB policy score less than 0, and the Progressive sample includes only those with a score greater than 3."}
bind_rows(
  acs_count_base %>%
    mutate(cat = case_when(origin_score > 3 ~ 'Progressive',
                             origin_score < 0 ~ 'Regressive'),
           marr_before_imm = marr_minus_imm < 0) %>%
    filter(mixed_citizenship == T & same_sex == T & !is.na(cat)) %>%
    group_by(year, cat, marr_before_imm) %>%
    summarize(n = sum(perwt)),
  acs_count_base %>%
    mutate(marr_before_imm = marr_minus_imm < 0) %>%
    filter(mixed_citizenship == T & same_sex == T) %>%
    group_by(year, marr_before_imm) %>%
    summarize(n = sum(perwt)) %>%
    mutate(cat = 'Full sample')) %>%
  filter(!is.na(marr_before_imm)) %>%
  mutate(marr_before_imm = ifelse(marr_before_imm == T, 'Marriage before immigration', 
                                  'Marriage after immigration')) %>%
  ggplot(aes(x = year, y = n/1000, color = cat, linetype = cat)) +
  geom_line(size = .3, ) +
  geom_vline(size = .3, xintercept = 2013, linetype = 2) +
  facet_wrap(~marr_before_imm) +
  labs(x = 'Year', y = 'n (thousands)') +
  theme(legend.text=element_text(size = 8))
```



```{r marr-desc-tab}
acs_count_base %>% 
  filter(!is.na(marr_minus_imm), married == T, mixed_citizenship == T) %>%
  mutate(marr_before = marr_minus_imm < 0) %>%
  group_by(same_sex, marr_before) %>%
  summarize(n_unweighted = n(),
            n_weighted = sum(perwt)) %>%
  select(`Same-sex` = same_sex, `Married before immigration` = marr_before,
         `n (unweighted)` = n_unweighted, `n (weighted)` = n_weighted) %>%
  kable(booktabs = T,
        format.args = list(big.mark = ","),
        caption = 'Among married, mixed-citizenship couples, counts of same-sex and different-sex couples that were married before and after immigration.')
```

\newpage

```{r marr-before-tab}
acs_count_mixed_marr_before <- count_func('marr_minus_imm < 0 | (married == T & mixed_citizenship == F)') 
count_origin_high_marr_before <- count_func('(origin_score > 3 | is.na(origin_score)) & 
                                            (marr_minus_imm < 0 | (married == T & mixed_citizenship == F))') 
count_origin_low_marr_before <- count_func('(origin_score < 0 |  is.na(origin_score)) & 
                                           (marr_minus_imm < 0 | (married == T & mixed_citizenship == F))')

mod_mixed <- acs_count_mixed_marr_before %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_high_marr_before, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_low_marr_before, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'
                ),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Married before immigration: Triple-difference (DDD), quasi-Poisson 
  regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying by 
  state-country-year-group average policy environment. Models include controls for state LGB policy, state unemployment, and state per-capita income. The full sample is limited to married couples, and the mixed-citizenship sample is limited to couples where the non-citizen partner immigrated after marriage.')
```
\newpage
```{r marr-after-tab}
acs_count_mixed_marr_after <- count_func('marr_minus_imm >= 0 | (married == T & mixed_citizenship == F)') 
count_origin_high_marr_after <- count_func('(origin_score > 3 | is.na(origin_score)) & 
                                           (marr_minus_imm >= 0 | (married == T & mixed_citizenship == F))') 
count_origin_low_marr_after <- count_func('(origin_score < 0 |  is.na(origin_score)) & 
                                          (marr_minus_imm >= 0 | (married == T & mixed_citizenship == F))')

mod_mixed <- acs_count_mixed_marr_after %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_high_marr_after, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_low_marr_after, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'
                ),
  note = "{stars}. The \"Regressive\" sample includes only countries with a LGB policy score less than 0, and the \"Progressive\" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.",
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Married after immigration: Triple-difference (DDD), quasi-Poisson 
  regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying by 
  state-country-year-group average policy environment. The full sample is limited to married couples, and the mixed-citizenship sample is limited to couples where the non-citizen partner immigrated before or in the same year as marriage.')
```

\newpage

# Lagged Origin-Country LGB Policy Score
```{r lag1-tab}
count_origin_high <- count_func('origin_score_lag1 > 3 | is.na(origin_score_lag1)') 
count_origin_low <- count_func('origin_score_lag1 < 0 |  is.na(origin_score_lag1)')

mod_mixed <- acs_count_mixed %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_high, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_low, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Country-of-origin LGB policy score lagged by one year: triple-difference (DDD), quasi-Poisson regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying by 
  state-country-year-group average policy environment')
```

\newpage

```{r lag2-tab}
count_origin_high <- count_func('origin_score_lag2 > 3 | is.na(origin_score_lag2)') 
count_origin_low <- count_func('origin_score_lag2 < 0 |  is.na(origin_score_lag2)')

mod_mixed <- acs_count_mixed %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_high, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_low, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Country-of-origin LGB policy score lagged by two years: triple-difference (DDD), quasi-Poisson regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying by 
  state-country-year-group average policy environment')
```

\newpage

```{r lag5-tab}
count_origin_high <- count_func('origin_score_lag5 > 3 | is.na(origin_score_lag5)') 
count_origin_low <- count_func('origin_score_lag5 < 0 |  is.na(origin_score_lag5)')

mod_mixed <- acs_count_mixed %>%
  glm(n ~ I(post_2013*same_sex*mixed) + 
        I(post_2013*same_sex) + 
        I(post_2013*mixed) + 
        post_2013 + 
        state_policy + state_income + state_unemploy +
        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_high, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = count_origin_low, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE',
                'State LGB policy' = 'state_policy',
                'State unemployment' = 'state_unemploy',
                'State per-capita income' = 'state_income'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Country-of-origin LGB policy score lagged by five years: triple-difference (DDD), quasi-Poisson regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying by 
  state-country-year-group average policy environment')
```

\newpage

# Parallel Trends Assumption for DD Model
```{r lag-plot-dd, fig.cap = 'Dynamic specifications of DD quasi-Poisson regression with two-way fixed effects for sample of only same-sex couples, displaying the coefficient for the Year × Mixed-citizenship interaction. Survey years are aggregated into pairs, with 2008-2009 as the base category.'}
count_origin_high <- count_func('origin_score > 3 | is.na(origin_score)') 
count_origin_low <- count_func('origin_score < 0 |  is.na(origin_score)')

base_plot_mod <- acs_count_mixed %>%
  filter(same_sex == T) %>%
  mutate(year = floor(year/2)*2) %>%
  group_by(state, year, same_sex, mixed, group_fe, state_policy, state_income, state_unemploy) %>%
  summarize(n = sum(n)) %>%
  ungroup() %>%
  mutate(year = factor(floor(year/2)*2, 
            levels = c('2018', '2016', '2014', '2012', '2010', '2008'))) %>%
  glm(n ~ as.factor(year):mixed + 
        as.factor(year) + group_fe + 
        state_policy + state_income + state_unemploy,
                        data = ., 
                        family = 'quasipoisson')

base_plot <- base_plot_mod %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
  tidy(conf.int = T) %>% 
  filter(str_detect(term, ':mixedTRUE')) %>%
  mutate(term = str_extract(term, '\\d\\d\\d\\d'),
         year = as.numeric(term)) %>%
  ggplot(aes(x = year, y = estimate)) +
    geom_pointrange(aes(ymin = conf.low, ymax = conf.high), size = .3) +
    geom_hline(yintercept = 0) +
    geom_vline(size = .3, xintercept = 2013, linetype = 2) +
    theme(panel.grid.major.y = element_line(size = .3), axis.line = element_line(size = .3), axis.ticks = element_line(size = .3), legend.position = "none") +
    labs(x = 'Year', y = 'Estimate', title = 'Full sample') +
    theme(panel.grid.major.y = element_line(size = .3), axis.line = element_line(size = .3), axis.ticks = element_line(size = .3), text = element_text(size = 8))



extra_pois_mixed_high <- glm(n ~ as.factor(year):mixed + 
        as.factor(year) + group_fe + 
        state_policy + state_income + state_unemploy,
                        data = count_origin_high %>%
                          filter(same_sex == T) %>%
                          mutate(year = factor(floor(year/2)*2, 
                                  levels = c('2018', '2016', '2014', '2012', '2010', '2008'))), 
                        family = 'quasipoisson')

extra_pois_mixed_low <- glm(n ~ as.factor(year):mixed + 
        as.factor(year) + group_fe + 
        state_policy + state_income + state_unemploy,
                        data = count_origin_low %>%
                          filter(same_sex == T) %>%
                          mutate(year = factor(floor(year/2)*2, 
                                  levels = c('2018', '2016', '2014', '2012', '2010', '2008'))), 
                        family = 'quasipoisson')

strat_plot <- bind_rows(
  extra_pois_mixed_high %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
    tidy(conf.int = T) %>% 
    filter(str_detect(term, ':mixedTRUE')) %>%
    mutate(year = as.numeric(str_extract(term, '\\d\\d\\d\\d')),
           mod = 'Score > 3'),
  extra_pois_mixed_low %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
    tidy(conf.int = T) %>%  
    filter(str_detect(term, ':mixedTRUE')) %>%
    mutate(year = as.numeric(str_extract(term, '\\d\\d\\d\\d')),
           mod = 'Score < 0')) %>%
  ggplot(aes(x = year, y = estimate, color = mod, shape = mod)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), 
                  position=position_dodge(width=.5), size = .3) +
  geom_hline(yintercept = 0) +
  geom_vline(size = .3, xintercept = 2013, linetype = 2)  + 
  theme(panel.grid.major.y = element_line(size = .3), axis.line = element_line(size = .3), axis.ticks = element_line(size = .3), legend.position=c(.18,.9)) +
  labs(x = 'Year', y = 'Estimate', title = 'Stratified') +
  theme(panel.grid.major.y = element_line(size = .3), axis.line = element_line(size = .3), axis.ticks = element_line(size = .3), text = element_text(size = 8))



p_combined <- base_plot + strat_plot
p_ranges_y <- c(ggplot_build(p_combined[[1]])$layout$panel_scales_y[[1]]$range$range,
                ggplot_build(p_combined[[2]])$layout$panel_scales_y[[1]]$range$range)
p_combined & 
  ylim(min(p_ranges_y), max(p_ranges_y))



base_test <- car::linearHypothesis(base_plot_mod, c('as.factor(year)2012:mixedTRUE=0',
                                     'as.factor(year)2010:mixedTRUE=0'),
                      singular.ok = TRUE)
base_test_p <- base_test$`Pr(>Chisq)`[2]

high_test <- car::linearHypothesis(extra_pois_mixed_high, c('as.factor(year)2012:mixedTRUE=0',
                                     'as.factor(year)2010:mixedTRUE=0'),
                      singular.ok = TRUE)

high_test_p <- high_test$`Pr(>Chisq)`[2]

low_test <- car::linearHypothesis(extra_pois_mixed_low, c('as.factor(year)2012:mixedTRUE=0',
                                     'as.factor(year)2010:mixedTRUE=0'),
                      singular.ok = TRUE)

low_test_p <- low_test$`Pr(>Chisq)`[2]

```

For the DD dynamic models, we test that coefficients for 2010 and 2012 are both equal to 0, $\delta_{2010} = \delta_{2012} = 0$. This pre-trend test follows a $\chi^2$ distribution. For the full sample, the $\chi^2$ value is `r base_test$Chisq[2]` with a p-value of `r base_test_p`. For the progressive subsample, the $\chi^2$ value is `r high_test$Chisq[2]` with a p-value of `r high_test_p`; here the pre-trend test provides evidence of parallel trends. We fail to reject the hypothesis that both coefficients are equal to 0, providing support for the parallel trends assumption in the pre-2013 period for both the full sample and the progressive subsample. 

\newpage

# Stratifying by U.S. State Policy
```{r state-stratify}
mod_mixed <- acs_count_mixed %>%
  glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) + 
        post_2013 + group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 



mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = filter(acs_count_mixed, state_policy >= 3), 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))


mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = filter(acs_count_mixed, state_policy <= 0), 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 

dddlist <- list('Full sample' = mod_mixed, 'Progressive States' = mod_os_high, 'Regressive States' = mod_os_low)

huxreg(dddlist,
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE'),
  note = '{stars}. The "Regressive" sample includes only U.S. states with a policy score less than 1, and the "Progressive" sample includes only those with a score greater than 2. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>% set_caption_pos('topleft') %>%
  huxtable::set_caption('Stratifying by U.S. state policy: Triple-differences (DDD), quasi-Poisson regressions of counts of 
                        individuals in mixed-citizenship, same-sex couples')

```



<!-- # 2015 Placebo -->
<!-- ```{r placebo-2015} -->
<!-- count_origin_high <- count_func('origin_score > 3 | is.na(origin_score)') %>% -->
<!--   mutate(post_2015 = year > 2015) -->
<!-- count_origin_low <- count_func('origin_score < 0 |  is.na(origin_score)') %>% -->
<!--   mutate(post_2015 = year > 2015) -->

<!-- mod_mixed <- acs_count_mixed %>% -->
<!--   mutate(post_2015 = year > 2015) %>% -->
<!--   glm(n ~ I(post_2015*same_sex*mixed) + I(post_2015*same_sex) + I(post_2015*mixed) + state_policy + state_income + state_unemploy + -->
<!--         post_2015 + group_fe + as.factor(year),  -->
<!--                         data = .,  -->
<!--                         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe))  -->



<!-- mod_os_high <- glm(n ~  I(post_2015*same_sex*mixed) +  -->
<!--                         I(post_2015*same_sex) +  -->
<!--                         I(post_2015*mixed) +  -->
<!--                         post_2015 + state_policy + state_income + state_unemploy + -->
<!--                         group_fe + as.factor(year),  -->
<!--                         data = count_origin_high,  -->
<!--                         family = 'quasipoisson') %>% -->
<!--   coeftest(., vcov = vcovCL(., cluster = ~group_fe)) -->


<!-- mod_os_low <- glm(n ~  I(post_2015*same_sex*mixed) +  -->
<!--                         I(post_2015*same_sex) +  -->
<!--                         I(post_2015*mixed) +  -->
<!--                         post_2015 + state_policy + state_income + state_unemploy + -->
<!--                         group_fe + as.factor(year),  -->
<!--                         data = count_origin_low,  -->
<!--                         family = 'quasipoisson') %>% -->
<!-- coeftest(., vcov = vcovCL(., cluster = ~group_fe))  -->

<!-- dddlist <- list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low) -->

<!-- huxreg(dddlist, -->
<!--        coefs = c('Post-2015 × Same-sex × Mixed-citizenship' = 'I(post_2015 * same_sex * mixed)', -->
<!--                 'Post-2015 × Same-sex'  = 'I(post_2015 * same_sex)', -->
<!--                 'Post-2015 × Mixed-citizenship'  = 'I(post_2015 * mixed)', -->
<!--                 'Post-2015' = 'post_2015TRUE', -->
<!--                 'State LGB policy' = 'state_policy', -->
<!--                 'State unemployment' = 'state_unemploy', -->
<!--                 'State per-capita income' = 'state_income'), -->
<!--   note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.', -->
<!--        stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001), -->
<!--        statistics = c('Observations' = 'nobs')) %>% -->
<!--   huxtable::set_width(1) %>% -->
<!--   set_wrap(T) %>% -->
<!--   set_all_padding(0) %>% set_caption_pos('topleft') %>% -->
<!--   huxtable::set_caption('2015 instead of 2013 intervention: Triple-differences (DDD), quasi-Poisson regressions of counts of individuals in mixed-citizenship, same-sex couples, stratifying the sample by policy environment at year of immigration') -->

<!-- ``` -->

\newpage

# References
