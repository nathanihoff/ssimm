---
output:
  bookdown::pdf_document2:
  # bookdown::word_document2:
  #   reference_docx: "word-template.docx"
    toc: no
    number_sections: yes
    pandoc_args: !expr rmdfiltr::add_wordcount_filter(rmdfiltr::add_citeproc_filter(args = NULL))
    latex_engine: xelatex
    keep_tex: no
    #template: svm-latex-ms.tex
# output: 
#   pdf_document:
#     citation_package: natbib
#     keep_tex: true
#     fig_caption: true
#     latex_engine: pdflatex
#     template: svm-latex-ms.tex
header-includes:
  - \usepackage{setspace}\doublespace
  - \usepackage{bbm}
editor_options: 
  
  chunk_output_type: console
citeproc: no
# fontfamily: mathpazo
mainfont: "Times New Roman"
fontsize: 12pt
geometry: margin=1in
indent: yes
link-citations: yes
linkcolor: blue
bibliography: "/Users/nathan/Google Drive/Projects/2020 Same-Sex Immigrant Couples/ssimm/Same-Sex Immigration.bib"
# csl: apa.csl
title: "Online Appendix"
subtitle: "Policy Effects on Mixed-Citizenship, Same-Sex Unions: A Triple-Difference Analysis"
# subtitle: "ASA 2022 Submission"
date: "`r format(Sys.time(), '%B %e, %Y')`"
# author:
# - Nathan I. Hoffmann, Department of Sociology, University of California, Los Angeles
# - Kristopher Velasco, Department of Sociology, Princeton University

---

<!-- Turn off hyphenation -->
<!-- \usepackage[none]{hyphenat} -->


```{r setup, include=F}
library(knitr)
library(broom)
library(huxtable)
library(sandwich)
library(lmtest)
library(here)
library(stargazer)
library(patchwork)
library(flextable)
library(tidyverse)
library(kableExtra)

knitr::opts_chunk$set(echo = F, warning = F, message = F, cache = T, # results = 'asis',
                      cache.lazy = F, dpi = 600)

# knitr::opts_chunk$set(error=TRUE) 

options("yaml.eval.expr" = TRUE)

uclablue = '#2774AE'
gray = '#808080'
black = '#000000'
uclagold = '#FFB81C'
ucla_palette = c(uclablue, black, gray)

# theme_set(theme_cowplot(font_family = 'Palatino') + 
theme_set(theme_classic(base_family = 'Palatino') + 
            theme(legend.title=element_blank(), 
                  panel.grid.major.y = element_line('grey80'),
                  legend.background = element_rect(fill = "transparent")))
# ggplot <- function(...) ggplot2::ggplot(...) + scale_color_manual(values = ucla_palette) +
#   scale_fill_manual(values = ucla_palette)
ggplot <- function(...) ggplot2::ggplot(...) + scale_color_brewer(palette="Dark2") +
  scale_fill_brewer(palette="Dark2")

# library(colorspace)
# colorspace_palette = 'RdPu'
# ggplot <- function(...) ggplot2::ggplot(...) +
#   scale_color_discrete_sequential(palette=colorspace_palette) +
#   scale_fill_discrete_sequential(palette=colorspace_palette)

options(scipen=1, digits=2)
knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark=",")
})
knitr::opts_chunk$set(error=TRUE) 

set_flextable_defaults(font.family = 'Times New Roman',
                       # padding.bottom = 1,
                       # padding.top = 1,
                       # padding.left = 3,
                       # padding.right = 1,
                       theme_fun = 'theme_booktabs',
                       digits = 3, 
                       big.mark = ',',
                       line_spacing = 1)

defOut <- knitr::knit_hooks$get("plot")  # save the default plot hook 
knitr::knit_hooks$set(plot = function(x, options) {  # set new plot hook ...
  x <- defOut(x, options)  # first apply the default hook
  if(!is.null(options$wrapfigure)) {  # then, if option wrapfigure is given ...
    # create the new opening string for the wrapfigure environment ...
    wf <- sprintf("\\begin{wrapfigure}{%s}{%g\\textwidth}", options$wrapfigure[[1]], options$wrapfigure[[2]])
    x  <- gsub("\\begin{figure}", wf, x, fixed = T)  # and replace the default one with it.
    x  <- gsub("{figure}", "{wrapfigure}", x, fixed = T)  # also replace the environment ending
  }
  return(x)
})
```

```{r load, include = F}
acs_count_base <- read_csv(here('data', 'acs_count_base.csv')) %>%
  filter(is.na(yrimmig) | !is.na(origin_score))
state_df <- read_csv(here('data', 'state_df.csv'))

count_func <- function(condition = '!is.na(state)'){
  acs_count_base %>%
    rename(mixed = mixed_citizenship) %>%
    filter(eval(rlang::parse_expr(condition))) %>%
    group_by(state, year, same_sex, mixed) %>%
    summarize(n = sum(perwt), 
              n_unweighted = n(),
              n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
              n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
    ungroup() %>%
    complete(state, year, same_sex, mixed) %>%
    mutate(across(n:n_unweighted_ar, function(x) ifelse(is.na(x), 0, x))) %>%
    mutate(post_2013 = year > 2013,
           group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
    left_join(state_df)
}

# acs_count_base %>%
#   filter(state == 'Alabama', year == 2008) %>%
#   group_by(same_sex, mixed_citizenship, bpldnew) %>%
#     summarize(n = sum(perwt), 
#               n_unweighted = n(),
#               n_ar = sum(perwt[qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F]), 
#               n_unweighted_ar = sum(qcitizen != 'Allocated' & qeduc != 'Consistency edit' & allocated == F)) %>%
#   group_by(same_sex, mixed_citizenship) %>%
#    summarize(n = sum(n),
#             n_unweighted = sum(n_unweighted),
#             n_ar = sum(n_ar),
#             n_unweighted_ar = sum(n_unweighted_ar))

acs_count_mixed <- count_func()




# acs_count_mixed <- read_csv(here('data', 'acs_count_mixed.csv')) %>%
#   group_by(state, year, same_sex, mixed) %>%
#   summarize(n = sum(n),
#             n_unweighted = sum(n_unweighted),
#             n_ar = sum(n_ar),
#             n_unweighted_ar = sum(n_unweighted_ar)) %>%
#   mutate(post_2013 = year > 2013,
#          group_fe = paste(state, same_sex, mixed, sep = '_'))
# acs_prop <- read.csv(here('data', 'acs_prop_yrimmig_policy.csv')) %>%
#   mutate(post_2013 = (yrimmig > 2013))
# acs_prop_state <- read.csv(here('data', 'acs_dyad_policy.csv'))

lgb_origin_index <- read_csv(here('data', 'lgb_origin_index.csv'))
acs_ind <- read_rds(here('data', 'acs_couple_policy.rds'))  %>%
  mutate(post_2013 = year > 2013
         # mixed =  mixed_citizenship = (citizen_main == 'Not a citizen' & citizen_partner != 'Not a citizen') | 
         #   (citizen_main != 'Not a citizen' & citizen_partner == 'Not a citizen')
         ) %>%
  left_join(lgb_origin_index,  by = c('yrimmig' = 'year', 'bpldid' = 'Code')) 

acs_count_mixed_bpld <- read_csv(here('data', 'acs_count_mixed.csv'))  %>%
  left_join(
    acs_ind %>%
      group_by(year, state, bpld, same_sex) %>% 
      summarize(across(c(equal_age:propaganda, origin_score), mean, na.rm = T))
      #summarize(origin_score = mean(origin_score))
  ) %>%
  filter(!is.na(origin_score) | bpld %in% unique({.$state}))



```

# Robustness Checks

## Adjusting proportions based on empirical mismatch rates

Published papers using the ACS to study same-sex couples overwhelmingly use the method by @gates_2009 employed our main paper to adjust for misreporting, where we drop all respondents that had either their relationship or sex variable allocated by the Census Bureau. However here we implement a novel method to adjust proportions of estimated immigrants in same-sex couples, based on the estimated mismatch rates from two U.S. Census Bureau studies. Beginning in 2019, the ACS provides explicit categories for "Opposite-sex husband/wife/spouse," "Opposite-sex unmarried partner," "Same-sex husband/wife/spouse," and "Same-sex unmarried partner" [@walker_2021], so sex misreporting in the 2019 data is unlikely, but we still adjust mismatch rates in these years as well.  

In a Census Bureau working paper, @kreider_2015 use personal information such as names and addresses match same-sex couples from the 2010 ACS to Social Security administrative data. They find that 7 percent of unmarried couples coded as same-sex in the ACS are coded as different-sex in the administrative data, and 57 percent of married same-sex couples. A follow-up study [@kreider_2017] shows that these mismatch rates appear to have fallen: In a 2016 ACS test module that included explicit categories for different- and same-sex spouses and partners, 31 percent of married and 3 percent of unmarried same-sex couples had inconsistent sex responses.  

To test the robustness of our results these levels of misreporting, we re-assign up to 60 percent of counts of individuals in same-sex couples to counts in different-sex couples, within state, year, and citizenship group. We then re-fit the models reported in the main paper. Coefficients for the three-way interaction of interest are shown in Figure \@ref(misreporting:plot). Results are extremely robust to even high levels of sex misreporting.  

```{r misreporting, eval = T}
count_origin_high <- 
  acs_count_mixed_bpld %>%
  filter(origin_score > 3 | is.na(origin_score)) %>%
  group_by(state, year, same_sex, mixed, post_2013, group_fe) %>%
  summarize(n = sum(n)) %>%
  ungroup() %>%
  complete(state, year, same_sex, mixed) %>%
  mutate(across(n, function(x) ifelse(is.na(x), 0, x)),
         post_2013 = year > 2013,
         group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
  left_join(state_df)

count_origin_low <- 
  acs_count_mixed_bpld %>%
  filter(origin_score < 0 | is.na(origin_score)) %>%
  group_by(state, year, same_sex, mixed, post_2013, group_fe) %>%
  summarize(n = sum(n)) %>%
  ungroup() %>%
  complete(state, year, same_sex, mixed) %>%
  mutate(across(n, function(x) ifelse(is.na(x), 0, x)),
         post_2013 = year > 2013,
         group_fe = paste(state, same_sex, mixed, sep = '_')) %>%
  left_join(state_df)

misreport <- function(dataset, rates = seq(0, 0.6, length.out = 7)){
  df <- dataset %>%
    select(state, year, same_sex, mixed, n) %>%
    pivot_wider(names_from = same_sex, values_from = n, names_prefix = 'same_sex_') 
  
  df[paste0(as.character(rates), '-TRUE')] <- round(sapply(1-rates, function(x)x*df$same_sex_TRUE))
  df[paste0(as.character(rates), '-FALSE')] <- round(sapply(rates, function(x){x*df$same_sex_TRUE + df$same_sex_FALSE}))
    
  df %>%
    select(-c(same_sex_FALSE, same_sex_TRUE)) %>%
    pivot_longer(cols = c(paste0(as.character(rates), '-TRUE'), paste0(as.character(rates), '-FALSE')),
                 names_sep = '-',
                 names_to = c('rate', 'same_sex'),
                 values_to = 'n') %>%
    mutate(same_sex = as.logical(same_sex)) %>%
    left_join(select(dataset, -starts_with('n')))
}

data_list <- list(
  'Full sample' = misreport(acs_count_mixed),
  'Progressive' = misreport(count_origin_high),
  'Regressive' = misreport(count_origin_low)
)

mis_list <- list()

# test <- misreport(count_origin_high)

for(rate_loop in as.character(unique(data_list[[1]]$rate))){
  for(dataset_num in 1:3){
    print(rate_loop)
    mis_list[[paste0(rate_loop, dataset_num, '1')]] <- data_list[[dataset_num]] %>%
      filter(rate == rate_loop) %>%
      glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) + 
          post_2013 + group_fe + as.factor(year), 
                          data = ., 
                          family = 'quasipoisson') %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
      tidy() %>%
      filter(term == 'I(post_2013 * same_sex * mixed)') %>%
      mutate(rate = as.numeric(rate_loop), 
             policy = names(data_list)[dataset_num],
             model = 'Main effects')
    
    mis_list[[paste0(rate_loop, dataset_num, '2')]] <- data_list[[dataset_num]] %>%
      filter(rate == rate_loop) %>%
      glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) + 
          state_policy + state_income + state_unemploy +
          post_2013 + group_fe + as.factor(year), 
                          data = ., 
                          family = 'quasipoisson') %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
      tidy() %>%
      filter(term == 'I(post_2013 * same_sex * mixed)') %>%
      mutate(rate = as.numeric(rate_loop), 
             policy = names(data_list)[dataset_num],
             model = 'With controls')
  }
}


write_csv(bind_rows(mis_list), here('did', 'misreporting_df.csv'))
```

```{r misreporting-plot}
misreporting_df <- read_csv(here('did', 'misreporting_df.csv'))

ggplot(misreporting_df, aes(x = rate, y = estimate, color = policy)) +
  geom_pointrange(aes(ymin = estimate - 1.96*std.error, ymax = estimate + 1.96*std.error), 
                  position = position_dodge(.02)) +
  facet_wrap(~model, ncol= 1) +
  geom_hline(yintercept = 0) +
  labs(x = 'Hypothetical misreporting rate', y = 'Coefficient for 3-way interaction')
```

\newpage

# Alternative Specifications: Main Model

```{r mod-tab2, eval = T}
mod_mixed <- acs_count_mixed %>%
  glm(n ~ I(post_2013*same_sex*mixed) + I(post_2013*same_sex) + I(post_2013*mixed) + 
        post_2013 + group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 

count_origin_high <- count_func('origin_score > 3 | is.na(origin_score)') 


mod_os_high <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = count_origin_high, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))

count_origin_low <- count_func('origin_score < 0 |  is.na(origin_score)')

mod_os_low <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = count_origin_low, 
                        family = 'quasipoisson') %>%
coeftest(., vcov = vcovCL(., cluster = ~group_fe)) 


huxreg(list('Full sample' = mod_mixed, 'Progressive' = mod_os_high, 'Regressive' = mod_os_low),
       coefs = c('Post-2013 × Same-sex × Mixed-citizenship' = 'I(post_2013 * same_sex * mixed)',
                'Post-2013 × Same-sex'  = 'I(post_2013 * same_sex)',
                'Post-2013 × Mixed-citizenship'  = 'I(post_2013 * mixed)',
                'Post-2013' = 'post_2013TRUE'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>%
  huxtable::set_caption('INDIVIDUAL LEVEL: STRATIFYING BY INDIVIDUAL POLICY ENVIRONMENT. Quasi-Poisson DDD regressions of counts of 
                        mixed-citizenship same-sex couples')
  # theme_compact()

base_effect <- tidy(mod_mixed) %>%
  filter(term == 'I(post_2013 * same_sex * mixed)') %>%
  pull(estimate) 
high_effect <- tidy(mod_os_high) %>%
  filter(term == 'I(post_2013 * same_sex * mixed)') %>%
  pull(estimate) 
```


```{r lag-plot2, eval = T, fig.height = 3.5, fig.cap = 'INDIVIDUAL-LEVEL: Dynamic specification of quasi-Poisson regression with two-way fixed effects, displaying the coefficient for the Year × Same-sex × Mixed-citizenship interaction. Survey years are aggregated into pairs, with 2008-2009 as the base category.'}
base_plot <- acs_count_mixed %>%
  mutate(year = floor(year/2)*2) %>%
  group_by(state, year, same_sex, mixed, group_fe) %>%
  summarize(n = sum(n)) %>%
  ungroup() %>%
  mutate(year = factor(floor(year/2)*2, 
            levels = c('2018', '2016', '2014', '2012', '2010', '2008'))) %>%
  glm(n ~ as.factor(year):same_sex:mixed + 
                        as.factor(year):same_sex + 
                        as.factor(year):mixed + 
                        as.factor(year) + group_fe,
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
  tidy(conf.int = T) %>% 
  filter(str_detect(term, ':same_sexTRUE:mixedTRUE')) %>%
  mutate(term = str_extract(term, '\\d\\d\\d\\d'),
         year = as.numeric(term)) %>%
  ggplot(aes(x = year, y = estimate)) +
    geom_pointrange(aes(ymin = conf.low, ymax = conf.high)) +
    geom_hline(yintercept = 0) +
    geom_vline(xintercept = 2013, linetype = 2) +
    theme(legend.position = "none") +
    labs(x = 'Year', y = 'Estimate', title = 'Full sample')



extra_pois_mixed_high <- glm(n ~ as.factor(year):same_sex:mixed + 
                        as.factor(year):same_sex + 
                        as.factor(year):mixed + 
                        as.factor(year) + group_fe,
                        data = mutate(count_origin_high, 
                                      year = factor(floor(year/2)*2, 
                                                    levels = c('2018', '2016', '2014', '2012', '2010', '2008'))), 
                        family = 'quasipoisson')

extra_pois_mixed_low <- glm(n ~ as.factor(year):same_sex:mixed + 
                        as.factor(year):same_sex + 
                        as.factor(year):mixed + 
                        as.factor(year) + group_fe,
                        data = mutate(count_origin_low, 
                                      year = factor(floor(year/2)*2, 
                                                    levels = c('2018', '2016', '2014', '2012', '2010', '2008'))), 
                        family = 'quasipoisson')

strat_plot <- bind_rows(
  extra_pois_mixed_high %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
    tidy(conf.int = T) %>% 
    filter(str_detect(term, ':same_sexTRUE:mixedTRUE')) %>%
    mutate(year = as.numeric(str_extract(term, '\\d\\d\\d\\d')),
           mod = 'Score > 3'),
  extra_pois_mixed_low %>%
    coeftest(., vcov = vcovCL(., cluster = ~group_fe)) %>%
    tidy(conf.int = T) %>%  
    filter(str_detect(term, ':same_sexTRUE:mixedTRUE')) %>%
    mutate(year = as.numeric(str_extract(term, '\\d\\d\\d\\d')),
           mod = 'Score < 0')) %>%
  ggplot(aes(x = year, y = estimate, color = mod, shape = mod)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high), position=position_dodge(width=.5)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 2013, linetype = 2)  + 
  theme(legend.position=c(.18,.9)) +
  labs(x = 'Year', y = 'Estimate', title = 'Stratified')



p_combined <- base_plot + strat_plot
p_ranges_y <- c(ggplot_build(p_combined[[1]])$layout$panel_scales_y[[1]]$range$range,
                ggplot_build(p_combined[[2]])$layout$panel_scales_y[[1]]$range$range)
p_combined & 
  ylim(min(p_ranges_y), max(p_ranges_y))
```

# Alternative Specifications: Policies
```{r policies-plot2, eval = T, fig.cap = 'COUNTRY-LEVEL: STATE-COUNTRY-YEAR-GROUPS WITH POLICY AVERAGE GREATER THAN 0.5. Stratified by specific policy: quasi-Poisson DDD regressions of counts of mixed-citizenship same-sex couples. Estimates and 95-percent confidence intervals are for the three-way interaction between indicators for same-sex, mixed-citizenship, and post-2013 survey year'}
policy_df <- read_csv(here('did', 'policy_df.csv'))

policy_list <- list()
variables <- names(subset(acs_count_mixed_bpld, select = equal_age:propaganda))

# for(var_name in variables){
#   policy_list[[var_name]] <- acs_ind %>%
#     filter(!!sym(var_name) == 1 | is.na(!!sym(var_name))) %>%
#     group_by(state, year, same_sex, mixed, post_2013, group_fe) %>%
#     summarize(n = sum(n)) %>% 
#     ungroup() %>%
#     complete(state, year, same_sex, mixed) %>%
#     mutate(across(n, function(x) ifelse(is.na(x), 0, x)),
#            post_2013 = year > 2013,
#            group_fe = paste(state, same_sex, mixed, sep = '_'))
# }

for(var_name in variables){
  dataset_policy <- acs_count_mixed_bpld %>%
    filter(!!sym(var_name) > .5
           | is.na(!!sym(var_name))) %>%
    group_by(state, year, same_sex, mixed, post_2013, group_fe) %>%
    summarize(n = sum(n)) %>%
    ungroup() %>%
    complete(state, year, same_sex, mixed) %>%
    mutate(across(n, function(x) ifelse(is.na(x), 0, x)),
           post_2013 = year > 2013,
           group_fe = paste(state, same_sex, mixed, sep = '_'))
  
  # dataset_policy <- count_func(paste0(var_name, ' > 0 | is.na(', var_name , ')'))
  
  policy_list[[var_name]] <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = dataset_policy, 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))
}

prog_policies <- c('equal_age', 'constitution', 'employment_discrim', 'hate_crimes',
                   'incite_hate', 'joint_adoption', 'lgb_military', 'marriage_equality',
                   'samesex_legal', 'civil_unions', 'conversion_therapies')
rep_policies <- c('unequal_age', 'death_penalty', 'lgb_military_ban', 
                  'marriage_ban', 'propaganda')

policy_df <- lapply(policy_list, function(x){
  tidy(x)[2, 2:3]}
  ) %>%
  bind_rows() %>%
  mutate(policy = names(policy_list),
         type = if_else(policy %in% prog_policies, 'Progressive', 'Regressive'),
         policy_name = recode(policy, 
                         equal_age = 'Equal age of consent', 
                         unequal_age = 'Unequal age of consent',
                         constitution = 'Constitutional protection',
                         conversion_therapies = 'Conversion therapy ban',
                         death_penalty = 'Death penalty',
                         employment_discrim = 'Employment protection',
                         hate_crimes = 'Hate-crime protection',
                         incite_hate = 'Incitement to hate banned',
                         joint_adoption = 'Joint adoption',
                         lgb_military = 'LGB military',
                         lgb_military_ban = 'LGB military ban',
                         marriage_equality = 'Marriage equality',
                         marriage_ban = 'Marriage ban',
                         samesex_legal = 'Same-sex acts legal',
                         civil_unions = 'Civil unions',
                         propaganda = 'Anti-propaganda laws'),
         lower = estimate - 1.96*std.error,
         upper = estimate + 1.96*std.error)

policy_df %>%
  ggplot(aes(reorder(policy_name, estimate), y = estimate)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  coord_flip() +
  facet_wrap(~type, scales = 'free_y') +
  labs(x = '', y = '')
```

```{r policies-plot3, eval = T, fig.cap = 'INDIVIDUAL LEVEL: ONLY INDIVIDUALS EXPERIENCING POLICY. Stratified by specific policy: quasi-Poisson DDD regressions of counts of mixed-citizenship same-sex couples. Estimates and 95-percent confidence intervals are for the three-way interaction between indicators for same-sex, mixed-citizenship, and post-2013 survey year'}
policy_df <- read_csv(here('did', 'policy_df.csv'))

policy_list <- list()
variables <- names(subset(acs_count_mixed_bpld, select = equal_age:propaganda))
dataset_policy_list <- list()

for(var_name in variables){
  print(var_name)
  dataset_policy_list[[var_name]] <- count_func(paste0(var_name, ' > 0 | is.na(', var_name , ')'))
  
  policy_list[[var_name]] <- glm(n ~  I(post_2013*same_sex*mixed) + 
                        I(post_2013*same_sex) + 
                        I(post_2013*mixed) + 
                        post_2013 + #state_policy + state_income + state_unemploy +
                        group_fe + as.factor(year), 
                        data = dataset_policy_list[[var_name]], 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))
}

prog_policies <- c('equal_age', 'constitution', 'employment_discrim', 'hate_crimes',
                   'incite_hate', 'joint_adoption', 'lgb_military', 'marriage_equality',
                   'samesex_legal', 'civil_unions', 'conversion_therapies')
rep_policies <- c('unequal_age', 'death_penalty', 'lgb_military_ban', 
                  'marriage_ban', 'propaganda')


policy_df <- lapply(policy_list, function(x){
  tidy(x)[2, 2:3]}
  ) %>%
  bind_rows() %>%
  mutate(policy = names(policy_list),
         type = if_else(policy %in% prog_policies, 'Progressive', 'Regressive'),
         policy_name = recode(policy, 
                         equal_age = 'Equal age of consent', 
                         unequal_age = 'Unequal age of consent',
                         constitution = 'Constitutional protection',
                         conversion_therapies = 'Conversion therapy ban',
                         death_penalty = 'Death penalty',
                         employment_discrim = 'Employment protection',
                         hate_crimes = 'Hate-crime protection',
                         incite_hate = 'Incitement to hate banned',
                         joint_adoption = 'Joint adoption',
                         lgb_military = 'LGB military',
                         lgb_military_ban = 'LGB military ban',
                         marriage_equality = 'Marriage equality',
                         marriage_ban = 'Marriage ban',
                         samesex_legal = 'Same-sex acts legal',
                         civil_unions = 'Civil unions',
                         propaganda = 'Anti-propaganda laws'),
         lower = estimate - 1.96*std.error,
         upper = estimate + 1.96*std.error)

policy_df %>%
  ggplot(aes(reorder(policy_name, estimate), y = estimate)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  coord_flip() +
  facet_wrap(~type, scales = 'free_y') +
  labs(x = '', y = '')


policy_desc_df <- list()
for(var_name in variables){
 policy_desc_df[[var_name]] <- dataset_policy_list[[var_name]] %>%
    filter(mixed == T & same_sex == T) %>%
    group_by(year) %>%
    summarize(n = sum(n)) %>%
    mutate(cat = var_name)
}

```

```{r policies-desc-plot, fig.height = 6.5, fig.cap = 'Counts of individuals in mixed-citizenship couples originating from countries with specific LGB policies'}
palette_dark <- RColorBrewer::brewer.pal(n=3,"Dark2")

p1 <- bind_rows(policy_desc_df) %>%
  filter(cat %in% prog_policies) %>%
  ggplot(aes(x = year, y = n/1000)) +
  geom_line(color = palette_dark[1]) +
  geom_vline(xintercept = 2013, linetype = 2) +
  facet_wrap(~cat) +
  labs(x = 'Year', y = 'n (thousands)', title = 'Progressive')

p2 <- bind_rows(policy_desc_df) %>%
  filter(!(cat %in% prog_policies)) %>%
  ggplot(aes(x = year, y = n/1000)) +
  geom_line(color = palette_dark[2]) +
  geom_vline(xintercept = 2013, linetype = 2) +
  facet_wrap(~cat) +
  labs(x = 'Year', y = 'n (thousands)', title = 'Regressive')  

p1 / p2 &
  ylim(c(0, 80)) 

# bind_rows(policy_desc_df) %>%
#   mutate(type = ifelse(cat %in% prog_policies, 'Progressive', 'Regressive')) %>%
#   ggplot(aes(x = year, y = n/1000, color = type)) +
#   geom_line() +
#   geom_vline(xintercept = 2013, linetype = 2) +
#   facet_wrap(~cat) +
#   labs(x = 'Year', y = 'n (thousands)')  

```

```{r policies-tab2, eval = T}

mod_policies_pooled <- acs_count_mixed_bpld %>%
  filter(mixed == T) %>%
  glm(n ~  I(post_2013*same_sex) + 
                        post_2013 + 
                        group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))

mod_policies_score <- acs_count_mixed_bpld %>%
  filter(mixed == T) %>%
  glm(n ~  I(post_2013*same_sex*origin_score) + 
        I(post_2013*same_sex) +
        post_2013  + group_fe + as.factor(year), 
                        data = ., 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))

prog_policies <- c('equal_age', 'constitution', 'employment_discrim', 'hate_crimes',
                   'incite_hate', 'joint_adoption', 'lgb_military', 'marriage_equality',
                   'samesex_legal', 'civil_unions', 'conversion_therapies')
rep_policies <- c('unequal_age', 'death_penalty', 'lgb_military_ban', 
                  'marriage_ban', 'propaganda')
policy_formula <- as.formula(paste0('n ~ I(post_2013*same_sex) + post_2013 + group_fe + as.factor(year) +  I(post_2013*same_sex*',
                        paste(c(prog_policies, rep_policies), 
                              collapse = ') + I(post_2013*same_sex*'),
                              ')'))


mod_policies <- glm(policy_formula, 
                    data = filter(acs_count_mixed_bpld, mixed == T), 
                        family = 'quasipoisson') %>%
  coeftest(., vcov = vcovCL(., cluster = ~group_fe))
  

huxreg(list(mod_policies_pooled, mod_policies_score, mod_policies),
       coefs = c('Post-2013 × Same-sex' = 'I(post_2013 * same_sex)',
                'Post-2013' = 'post_2013TRUE',
                'Post-2013 × Same-sex × Policy score' = 'I(post_2013 * same_sex * origin_score)',
                'Civil unions' = 'I(post_2013 * same_sex * civil_unions)',
                'Marriage equality' = 'I(post_2013 * same_sex * marriage_equality)',
                'Equal age of consent' = 'I(post_2013 * same_sex * equal_age)', 
                'Constitutional protection' = 'I(post_2013 * same_sex * constitution)',
                'Conversion therapy ban' = 'I(post_2013 * same_sex * conversion_therapies)',
                'Employment protection' = 'I(post_2013 * same_sex * employment_discrim)',
                'Hate-crime protection' = 'I(post_2013 * same_sex * hate_crimes)',
                'Incitement to hate banned' = 'I(post_2013 * same_sex * incite_hate)',
                'Joint adoption' = 'I(post_2013 * same_sex * joint_adoption)',
                'LGB military' = 'I(post_2013 * same_sex * lgb_military)',
                'Same-sex acts legal' = 'I(post_2013 * same_sex * samesex_legal)',
                'Unequal age of consent' = 'I(post_2013 * same_sex * unequal_age)',
                'Death penalty' = 'I(post_2013 * same_sex * death_penalty)',
                'LGB military ban' = 'I(post_2013 * same_sex * lgb_military_ban)',
                'Marriage ban' = 'I(post_2013 * same_sex * marriage_ban)',
                 'Anti-propaganda laws' = 'I(post_2013 * same_sex * propaganda)'),
  note = '{stars}. The "Regressive" sample includes only countries with a LGB policy score less than 0, and the "Progressive" sample includes only those with a score greater than 3. Group-clustered standard errors shown in parentheses. Source: American Community Survey 2008-2019. Authors\' calculations.',
       stars = c(`†` = 0.1, `*` = 0.05, `**` = 0.01, `***` = 0.001),
       statistics = c('Observations' = 'nobs')) %>%
  huxtable::set_width(1) %>%
  set_wrap(T) %>%
  set_all_padding(0) %>%
  huxtable::set_caption('Quasi-Poisson DiD regressions of counts of 
                        mixed-citizenship same-sex couples, stratifying by state-country-year-group average policy environment. The sample is limited to mixed-citizenship couples only.')
```



\newpage

# References
